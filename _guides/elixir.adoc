:encoding: UTF-8
:lang: en
:doctype: book
:toc: left
:source-highlighter: rouge

= Elixir

== categories: ["elixir"]


== Contents

* Will be replaced with the ToC, excluding the "Contents" header

== TODO

Functional programming is about making the complex parts of your system explicit.

Questions
What are the strengths of Erlang?
Why is the programming world becoming more interested in concurrency, distributed systems and functional languages?
Can you contrast how errors are handled in Erlang and Elixir, compared to other languages?
What was the reason for building Elixir? What did Erlang lack?
Elixir compiles to bytecode for the Erlang VM – what does this mean?
What is meta programming?
How is the adoption of Phoenix and where is it headed?

http://softwareengineeringdaily.com/2016/04/18/elixir-erlang-jose-valim/[http://softwareengineeringdaily.com/2016/04/18/elixir-erlang-jose-valim/]

* `@behaviour  @callback   @macrocallback @optional_callbacks`
* https://hexdocs.pm/elixir/naming-conventions.html#content[Naming Convention]

Review Elixir 0.14 release http://elixir-lang.github.io/blog/2014/06/17/elixir-v0-14-0-released/ :

* @derive
* Protocol consolidation
* Nested Structure access

Review Elixir 0.15 release http://elixir-lang.github.io/blog/2014/08/07/elixir-v0-15-0-released/

Review Elixir 1.3 release http://elixir-lang.github.io/blog/2016/06/21/elixir-v1-3-0-released/ and https://tuvistavie.com/2016/elixir-1-3/#exunit-new-features : 
 
* Deprecation of imperative assignment  *IMPORTANT!!!*
* Calendar types and sigils
* Access selectors
* mix xref
* mix app.tree and deps.tree
* mix escript.install                   *IMPORTANT!!!*
* Option parser integration
* ExUnit: 
** mix test --stale, DONE <<Execute only stale tests, Execute only stale tests>> ,
** Diffing, DONE <<Diffing,Diffing>> ,
** Test types,
** Named setups and describes

Review Elixir 1.4 release http://elixir-lang.github.io/blog/2017/01/05/elixir-v1-4-0-released/ :

* Registry
* Iex Syntax coloring
* Task.async_stream
* Application inference
* Mix install escript from SCM

Review Elixir 1.5 release http://elixir-lang.github.io/blog/2017/07/25/elixir-v1-5-0-released/ :

* UTF-8 atoms, function names and variables DONE
* IEx helpers and breakpoints
* Exception.blame
* Streamlined child specs
* @impl DONE
* Calendar improvements



review Elixir 1.6 release https://github.com/elixir-lang/elixir/releases/tag/v1.6.0-rc.0 :

* https://soundcloud.com/elixirtalk/episode-106-chat-with-jose-valim?utm_campaign=elixir_radar_124&utm_medium=email&utm_source=RD+Station

== Resources

* https://drive.mindmup.com/map/0By_bGJI79BIpa1hOUW1rcjJNeEE[My Elixir Mind Map ]

* Awesome Elixir: https://github.com/h4cc/awesome-elixir[https://github.com/h4cc/awesome-elixir]
* Trending on Github: https://github.com/trending/elixir[https://github.com/trending/elixir]
* Static code analyzer: https://github.com/rrrene/credo[https://github.com/rrrene/credo]
* code style: https://github.com/rrrene/elixir-style-guide[https://github.com/rrrene/elixir-style-guide]
* Docker Hub: https://hub.docker.com/_/elixir/[https://hub.docker.com/_/elixir/]
* https://elixirforum.com/[https://elixirforum.com/]
* http://elixirstream.com/[http://elixirstream.com/]
* http://joearms.github.io/2013/05/31/a-week-with-elixir.html[http://joearms.github.io/2013/05/31/a-week-with-elixir.html]

Books:

* 2016 THE LITTLE ELIXIR &amp; OTP GUIDEBOOK: http://benjamintan.io/[http://benjamintan.io/]
* "Metaprogramming Elixir" by Chris McCord the author of Phoenix https://pragprog.com/book/cmelixir/metaprogramming-elixir[https://pragprog.com/book/cmelixir/metaprogramming-elixir]
* https://happi.github.io/theBeamBook[The BEAM Book] 

Elixir release notes:

* All: http://elixir-lang.org/blog/categories.html#Releases[http://elixir-lang.org/blog/categories.html#Releases]
* http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/[http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/]
* http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/[http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/]
* derive
* Protocol consolidation
* Nested access
* Mix and OTP
*
* Full release: https://github.com/elixir-lang/elixir/releases/tag/v1.4.0[https://github.com/elixir-lang/elixir/releases/tag/v1.4.0]
* Registry
* Syntax coloring
* Task.async_stream
* Application inference
* Mix install from SCM

= People and companies

* José Valim, Founder and Director of Research and Development at Plataformatec
* https://www.linkedin.com/in/jovalim[https://www.linkedin.com/in/jovalim]
*

= IEx

Doc: https://hexdocs.pm/iex/IEx.html#summary[https://hexdocs.pm/iex/IEx.html#summary]

* Print the current config `IEx.configuration()`
* https://hexdocs.pm/iex/IEx.html#module-shell-history[Enable History in erlang 20]:`export ERL_AFLAGS="-kernel shell_history enabled"`


= Atom Elixir

https://brainlid.org/elixir/2015/11/12/atom-editor-and-elixir.html[https://brainlid.org/elixir/2015/11/12/atom-editor-and-elixir.html]

= CHEATSHEET

IEx:

* Help from iex: `h String`
* `~/.iex.exs` and local `.iex.exs`
* inspect (implement proto, etc): `i &quot;hello&quot;`
* `#iex:break` Cancel a multiline command
*

Cheatsheet: https://media.pragprog.com/titles/elixir/ElixirCheat.pdf[https://media.pragprog.com/titles/elixir/ElixirCheat.pdf]

* Start a script: `iex math.exs`

= Install Elixir, Erlang and hex

Docker Example:

* Erlang image: https://github.com/c0b/docker-erlang-otp/blob/ea32d5f6f1735f9f55bee04b112166da96eb9c73/19/Dockerfile[https://github.com/c0b/docker-erlang-otp/blob/ea32d5f6f1735f9f55bee04b112166da96eb9c73/19/Dockerfile]
* Elixir image: https://github.com/c0b/docker-elixir/blob/22ee98417200ef8d9a049b2b4504e7cf279e911f/1.2/Dockerfile[https://github.com/c0b/docker-elixir/blob/22ee98417200ef8d9a049b2b4504e7cf279e911f/1.2/Dockerfile]

== Install Multiple versions

EVM Switching between multiple Erlang versions:

* evm https://medium.com/@ivorpaul/switching-between-multiple-erlang-versions-5559923ea7cd#.24kbmsk9x[https://medium.com/@ivorpaul/switching-between-multiple-erlang-versions-5559923ea7cd#.24kbmsk9x]
* kerl: `brew install kerl`

Manage multiple Elixir version with Kiex:

* `brew install kiex`
* To install https://github.com/taylor/kiex[https://github.com/taylor/kiex]
* http://learningelixir.joekain.com/installing-multiple-elixir-version-with-kiex/[http://learningelixir.joekain.com/installing-multiple-elixir-version-with-kiex/]
* `kiex use 1.3.4`

Another alternative is https://github.com/asdf-vm/asdf[ASDF]

== Erlang-Elixir Code Portability

http://stackoverflow.com/questions/2255658/how-portable-are-erlang-beam-files[http://stackoverflow.com/questions/2255658/how-portable-are-erlang-beam-files]

== Editor - IDE

=== Intellij

* `brew cask install intellij-idea-ce` ce = comunity edition

= Mix

A build tool that ships with Elixir.

Ref:

* into: http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html[http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html]
* https://hexdocs.pm/mix/Mix.html[Mix doc]

Mix that provides tasks for:

* creating,
* compiling,
* testing your application,
* managing its dependencies and much more;

TODO:

* archive.install
* doc: `mix help archive.install`

Non ho capito come avere versioni multiple di phoenix e perchè non si usa hex….

* `mix archive.install hex hex_package` or `mix archive.install hex hex_package 1.2.3` :
[source, elixir]
----
 mix archive.install https://github.com/phoenixframework/archives/raw/master/phoenix_new.ez
Found existing archive: /Users/nicolabrisotto/.mix/archives/phoenix_new-1.2.1.
Are you sure you want to replace it with "https://github.com/phoenixframework/archives/raw/master/phoenix_new.ez"? [Yn] Y
----

* nerves.new
* deps.get
* compile
* firmware
* OTP application: come va gestita la voce "application" in un progetto gestito con Mix ?

== Project Structure

* ebin - contains the compiled bytecode
* lib - contains elixir code (usually .ex files)
* test - contains tests (usually .exs files)

== Create a simple Mix Project

http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html#our-first-project[http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html#our-first-project]

`-S option` to run scripts: `iex -S mix`

== Running Mix commands from any directory

https://robots.thoughtbot.com/running-project-mix-commands-from-any-directory[https://robots.thoughtbot.com/running-project-mix-commands-from-any-directory]

== Custom Mix Tasks

* https://medium.com/blackode/mix-task-creation-in-elixir-project-d89e49267fe3#.crf3y6ic3[Tutorial]
* http://elixir-recipes.github.io/mix/custom-mix-task/[Doc]

=== HOWTO Test Mix Tasks

https://jc00ke.com/2017/04/05/testing-elixir-mix-tasks/[https://jc00ke.com/2017/04/05/testing-elixir-mix-tasks/]

== Mix Alias

https://sergiotapia.me/alias-your-phoenix-mix-commands-for-some-nice-developer-ux-4a02b2bf3474#.i9ag1tbd1[https://sergiotapia.me/alias-your-phoenix-mix-commands-for-some-nice-developer-ux-4a02b2bf3474#.i9ag1tbd1]

== Mix Xref

Ref: http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/[http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/]

`mix xref unreachable`:

* performs cross reference checks in your code and find calls to modules and functions that do not exist.
* Since such checks can discover possible bugs in your codebase, a new compiler called xref has been added to Mix.compilers/0, so it runs by default every time you compile your code.

`mix xref callers Foo` or `mix xref callers Ecto.Queryable.to_query/1`
* used to find all places in your code that calls a function from the module Foo

* `mix xref graph` - generates a graph with dependencies between source files

== Mix app.tree and deps.tree

list all applications your current project needs to start in order to boot (i.e. the ones listed in application/0 in your mix.exs) while the second will lists all of your dependencies and so on recursively

* mix deps.tree –format dot –only prod
* `--format dot` option can also be given to generate graph files to be opened by GraphViz.

== Mix task commandline options

Elixir v1.3 includes improvements to the option parser, including OptionParser.parse!/2 and OptionParser.parse_head!/2 functions that will raise in case of invalid or unknown switches. Mix builds on top of this functionality to provide automatic error reporting solving a common complaint where invalid options were not reported by Mix tasks.

For example, invoking mix test –unknown in earlier Elixir versions would silently discard the –unknown option. Now mix test correctly reports such errors:

[source, elixir]
----
$ mix test --unknown
** (Mix) Could not invoke task "test": 1 error found!
--unknown : Unknown option
----

= HEX

* https://github.com/hexpm/hex[Hex Homepage]
* https://hex.pm/docs/usage[https://hex.pm/docs/usage]

Hex is a package manager for the Erlang ecosystem.

This project currently provides tasks that integrate with Mix, Elixir's build tool.

= Testing and code quality

== Code coverage

https://github.com/parroty/excoveralls[https://github.com/parroty/excoveralls] + optionally coveralls.io service

== Profiling

Using kcachegrind: http://blog.equanimity.nl/blog/2013/04/24/fprof-kcachegrind/[http://blog.equanimity.nl/blog/2013/04/24/fprof-kcachegrind/]

== Best Practices

=== When to Use Structs, String-keyed Maps, and Atom-keyed Maps

https://engineering.appcues.com/2016/02/02/too-many-dicts.html[https://engineering.appcues.com/2016/02/02/too-many-dicts.html]

== Dialyzer and Dialyxir

https://github.com/jeremyjh/dialyxir[https://github.com/jeremyjh/dialyxir]

http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html[http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html]

Dialyzer uses a typing-inference algorithm called `success typings`. Success typings are optimistic:

* Assume that all your functions are used correctly. In other words, your code is innocent until proven guilty.
* Starts by over-approximating the valid inputs to and outputs from your functions.
* As the algorithm develops a better understanding of your code, it generates constraints. Example:
* it sees x + y, then x and y must be numbers.
* Guards such as is_atom(z) provide additional constraints.

NOTE: Dialyzer doesn’t guarantee that your code is type-safe. If it finds something wrong, Dialyzer is guaranteed to be correct.

Revealing types with iex helpers:

* `t/1` prints the types for the given module or for the given function/arity pair (ex: t Enum)
* `i/1` prints information about the given data type (ex: `i(&quot;ohai&quot;)`, `i(&#39;ohai&#39;)`)

Dialyzer messages:

`no local return` means the function will definitely fail, Dialyzer has found a type error, the function can never return.

=== Examples

see `~/SRC/ELIXIR/testbed/dialyzer_playground` and The_Little_Elixir_&amp;_OTP_Guidebook.pdf CH 10.4.

=== Persistent Lookup Table (PLT)

* Dialyzer stores the result of an analysis in a Persistent Lookup Table (PLT).
* You can also use a previously constructed PLT that serves as a starting point for Dialyzer.
* any nontrivial Elixir application will probably involve OTP; if you run Dialyzer on such an application, the analysis will undoubtedly take a long time, you can always build a base PLT and only run Dialyzer on your application, which by comparison will take much less time. But when you upgrade Erlang and/or Elixir, you must remember to rebuild the PLT.

=== Dialyxir

Mix tasks to simplify use of Dialyzer in Elixir projects.

= ExUnit

https://elixirschool.com/en/lessons/basics/testing/[Getting Started]

TODO: 

* https://medium.com/onfido-tech/the-not-so-magic-tricks-of-testing-in-elixir-1-2-89bfcf252321

== Test Types

ExUnit v1.3 includes the ability to register different test types. This means libraries like QuickCheck can now provide functionality such as:

[source, elixir]
----
defmodule StringTest do
  use ExUnit.Case, async: true
  use PropertyTestingLibrary

  property "starts_with?" do
    forall({s1, s2} <- {utf8, utf8}) do
      String.starts_with?(s1 <> s2, s1)
    end
  end
end
----

At the end of the run, ExUnit will also report it as a property, including both the amount of tests and properties:

[source, elixir]
----
1 property, 10 tests, 0 failures
----

=== Quick check style test

REF:

* Ref: https://github.com/parroty/excheck[https://github.com/parroty/excheck]
* QuickCheck http://www.cse.chalmers.se/~rjmh/QuickCheck/[http://www.cse.chalmers.se/~rjmh/QuickCheck/]

== Describe Blocks

Organize tests together in describe blocks:

[source, elixir]
----
defmodule StringTest do
  use ExUnit.Case, async: true

  describe "String.capitalize/2" do
    test "uppercases the first grapheme" do
      assert "T" <> _ = String.capitalize("test")
    end

    test "lowercases the remaining graphemes" do
      assert "Test" = String.capitalize("TEST")
    end
  end
end
----

Every test inside a describe block will be tagged with the describe block name. This allows developers to run tests that belong to particular blocks, be them in the same file or across many files:

[source, elixir]
----
$ mix test --only describe:"String.capitalize/2"
----

Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, we want developers to build on top of named setups. For example:

[source, elixir]
----
defmodule UserManagementTest do
  use ExUnit.Case, async: true

  describe "when user is logged in and is an admin" do
    setup [:log_user_in, :set_type_to_admin]

    test ...
  end

  describe "when user is logged in and is a manager" do
    setup [:log_user_in, :set_type_to_manager]

    test ...
  end

  defp log_user_in(context) do
    # ...
  end
end
----

By restricting hierarchies in favor of named setups, it is straight-forward for the developer to glance at each describe block and know exactly the setup steps involved.

== Execute only stale tests

Ref: http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/[http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/]

`mix test --stale` builds on top of `mix xref`: will only run the tests that may have changed since the last time you ran mix test –stale.

For example:

* If you saved a test file on disk, Mix will run that file and ignore the ones that have not changed
* If you changed a library file, for example, lib/foo.ex that defines Foo, any test that invokes a function in Foo directly or indirectly will also run
* If you modify your mix.exs or your test/test_helper.exs, Mix will run the whole test suite

This feature provides a great workflow for developers, allowing them to effortlessly focus on parts of the codebase when developing new features.

== Diffing

From Elixir 1.3 

For this addition, `String.myers_difference/2` has been added to the String module.

[source, elixir]
----
iex(1)> String.myers_difference("foobar", "fopbar")
[eq: "fo", del: "o", ins: "p", eq: "bar"]
----

= Debug and Monitoring

== Erlang Observer

`:observer.start`

* See how much load the VM is taking
* See the layout of your supervision trees

== IEx.pry

[source, elixir]
----
require IEx

IEx.pry
----

To run pry within a test suite:

`iex -S mix test`



https://www.youtube.com/watch?v=LE2y4kh56pQ[Elixir 1.5 addition and tips] :

* Set break points
* Require private functions
* Print why a function didn't match



= Deployment production Monitoring

== Distillery

Distillery is A pure Elixir implementation of release packaging functionality for the Erlang VM.

https://github.com/bitwalker/distillery

takes your Mix project and produces an Erlang/OTP release, a distilled form of your raw application's components; a single package which can be deployed anywhere, independently of an Erlang/Elixir installation. No dependencies, no hassle.

https://blog.dockbit.com/deploying-elixir-applications-with-docker-1e1dd5b39ab9 :

* Snippet to sync Phoenix version with image name https://github.com/DockbitExamples/phoenix/commit/4f54c9c6cf10034370b68586cdf5ae5de34a7848

* https://zorbash.com/post/docker-multi-stage-elixir-distillery-releases/

NOTE: Exrm has been replaced by Distillery

== How to create a standalone executable

https://www.reddit.com/r/elixir/comments/5e4ti2/building_a_standalone_cli_executable/



= Are Elixir variables really immutable?

* http://stackoverflow.com/questions/29967086/are-elixir-variables-really-immutable[http://stackoverflow.com/questions/29967086/are-elixir-variables-really-immutable]
* http://blog.plataformatec.com.br/2016/01/comparing-elixir-and-erlang-variables/[http://blog.plataformatec.com.br/2016/01/comparing-elixir-and-erlang-variables/]

In Elixir, once a variable references a list such as [1,2,3], you know it will always reference those same values (until you rebind the variable).

== What is the difference between mutability and rebinding?

[source, elixir]
----
name = "elixir"     
cap_name = String.capitalize name
"Elixir"     
name    
"elixir"
----

* The data structure referenced by name is never changed
* In functional we never tranform data

= Types

Elixir’s built-in types are

Value types:
Arbitrary-sized integers
Floating-point numbers
Atoms
Ranges
Regular expressions

System types:
PIDs and ports
References

Collection types:
Tuples
Lists
Maps
Binaries

In Elixir, functions are a type too.

String and structures are built using the types above

== Type Safety: type checking

http://learningelixir.joekain.com/elixir-type-safety/[http://learningelixir.joekain.com/elixir-type-safety/]

== Integer

Binary, hexdecimal, octal:

[source, elixir]
----
iex(14)> 0b101
5
iex(15)> 0xaf
175
iex(16)> 0o10
8
----

Sugar, use underscore to improve readability : `1_000_000`

== Float

`1.0   0.2456   0.314159e1 314159.0e-5`

== Truth

* `true`, `:true` is its alias
* `false`, `nil`
* In most context any value other than `nil` or `false` is treated as `true` 

== Binaries

* Data binary type: to access data as a sequence of bits or bytes
* Litterals are enclosed between `&lt;&lt; &gt;&gt;`
* http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html[http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html]
[source, elixir]
----
iex(8)> bin = << 1, 2 >>
<<1, 2>>
iex(9)> byte_size bin
2
----

You can add modifiers to control the type and size of each individual field:

[source, elixir]
----
iex> bin = << 1::size(1), 0::size(7) >>
<<128>>
iex(25)> :io.format("~8.2b~n", :binary.bin_to_list(bin))
10000000

iex> bin = << 1::size(1), 1::size(7) >>
<<129>>
iex(23)> :io.format("~8.2b~n", :binary.bin_to_list(bin))
10000001
----

TODO: come funziona la stampa con :io.format ??? è Erlang…
TODO: non ho ben capito come si gestiscono Binaries con più di 8 bit

[source, elixir]
----
bin = << 1::size(1), 0::size(8) >>
 <<128, 0::size(1)>>
----

== Strings

* By default are encoded in UTF-8
* represented internally by binaries which are sequences of bytes
* http://elixir-lang.org/docs/stable/elixir/String.html#content[String module doc]

String interpolation:

[source, elixir]
----
name="nicola"
"ciao #{name}"
-> "ciao nicola"
----

Print string: `IO.puts &quot;hello\nworld&quot;`

=== Binaries, strings and char lists

http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html[http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html]

* String byte size and length are different

[source, elixir]
----
byte_size("hellö") # ö is encoded with 2 bytes
6

byte_size("hello")
5

String.length("hellö")
5

String.length("hello")
5
----

== Atoms

Atoms are constants that represent something’s name. We write them using a leading colon (:)

`:fred  :is_binary?  :var@2  :&lt;&gt;  :===  :&quot;func/3&quot;  :&quot;long john silver&quot;`

Two atoms with the same name will always compare as being equal, even if they were created by different applications on two computers separated by an ocean.

We’ll be using atoms a lot to tag values.

== Calendar and sigils

Calendar and Date, Time, NaiveDateTime and DateTime types was added in 1.3, see here:

* https://github.com/elixir-lang/elixir/releases/tag/v1.3.0[https://github.com/elixir-lang/elixir/releases/tag/v1.3.0]
* http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/[http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/]

== Ranges

start..end

== RegExp

~r{regexp} or ~r{regexp}opts or ~r/…/

Based on PCRE that provides a Perl-5

http://elixir-lang.org/docs/stable/elixir/Regex.html[http://elixir-lang.org/docs/stable/elixir/Regex.html]

== PIDs and Ports

PID is a reference to a local or remote process

`self` is the PID

== Anonymous functions

Functions are delimited by the keywords `fn` and `end`:

[source, elixir]
----
add = fn a, b -> a + b end
is_function(add)
iex> is_function(add, 2) # Test function's arity
true
iex> is_function(add, 1)
false
iex> add.(1, 2)
3
----

* Functions are “first class citizens” in Elixir meaning they can be passed as arguments
* dot (.) between the variable and parenthesis is required to invoke an anonymous function.
* CLOSURE: anonymous functions are closures
[source, elixir]
----
iex> add_two = fn a -> add.(a, 2) end
 #Function<6.71889879/1 in :erl_eval.expr/5>
iex> add_two.(2)
4
----

* A variable assigned inside a function does not affect its surrounding environment:
[source, elixir]
----
iex> x = 42
42
iex> (fn -> x = 0 end).()
0
iex> x
42
----

== References

TODO make_ref

== Collections

Elixir collections can hold values of any type (including other collections).

=== Best Practices

=== Tuples

Ordered collection

`{ 1, 2 }      { :ok, 42, &quot;next&quot;  }   { :error, :enoent }`

CONVENTION:

* A typical Elixir tuple has two to four elements, any more and you’ll probably want to look at maps, or structs.
* It is common for functions to return a tuple where the first element is the atom :ok. A common idiom is to write matches that assume success
[source, elixir]
----
iex> { :ok, file } = File.open("Rakefile")
{:ok, #PID<0.39.0>}
iex> { :ok, file } = File.open("non-existent-file")
** (MatchError) no match of right hand side value: {:error, :enoent}
----

The second open failed, and returned a tuple where the first element was :error.

Patter matching:

[source, elixir]
----
iex> {status, count, action} = {:ok, 42, "next"}
{:ok, 42, "next"}
iex> status  
:ok          
iex> count   
42           
iex> action  
"next"

----

=== Lists

`[1,2,3]`

Are like linked list:

* head contains a value
* tails contains the list
* O(1) easy to traverse linearly
* O(n) expensive to access in random order (to get to the nth element, you have to scan through n–1 previous elements)
[source, elixir]
----
“Chapter 7, Lists and Recursion, ”
----

Excerpt From: Thomas, Dave. “Programming Elixir: Functional |&gt; Concurrent |&gt; Pragmatic |&gt; Fun.” iBooks.

remove the head is cheap because also if the list is immutable you can return a pointer to the tail structure (which contains the whole data except the head)

[source, elixir]
----
[ 1, 2, 3 ] ++ [ 4, 5, 6 ]      # concatenation
[1, 2, 3, 4] -- [2, 4]           # difference
1 in [1,2,3,4]                   # membership
true         
iex> "wombat" in [1, 2, 3, 4]
false        
----

==== Keywords List

* Allow more entries for a given key (!= map)

SHORTCUT to generate a list of key value tuples (a KEYWORD LIST):

`[ name: &quot;Dave&quot;, city: &quot;Dallas&quot;, likes: &quot;Programming&quot; ]`

Elixir converts it into a list of two-value tuples:

`[ {:name, &quot;Dave&quot;}, {:city, &quot;Dallas&quot;}, {:likes, &quot;Programming&quot;} ]`

`DB.save record, [ {:use_transaction, true}, {:logging, &quot;HIGH&quot;} ]` is equivalent to `DB.save record, use_transaction: true, logging: &quot;HIGH&quot;`


Elixir allow also a more implicit conversion:

“We can leave off the brackets if a keyword list appears as the last item in any context where a list of values is expected.

`iex&gt; [1, fred: 1, dave: 2]`

Will be converted into `[1, {:fred, 1}, {:dave, 2}]`

and printed as `{1, [fred: 1, dave: 2]}`

in pratica una tuple di 2 elementi dentro una lista viene sempre stampata come una keyword list

=== Maps

* Allow only one entry for a given key (!= keyword list)
* Efficient as they grow
* can be used with pattern matching
* use it when you need associative arrays
[source, elixir]
----
states = %{ "AL" => "Alabama", "WI" => "Wisconsin" }

response_types = %{ { :error, :enoent } => :fatal, { :error, :busy } => :retry }

colors = %{ red: 0xff0000, green: 0x00ff00, blue: 0x0000ff }

----

Accessing:

* If the keys are atoms, you can also use a dot notation: `colors.green`
* `states[&quot;AL&quot;]`
* `response_types[{:error,:busy}]`

==== Map keys: Symbol VS String

Ref: http://learningwithjb.com/posts/the-many-different-ways-to-key-elixir-maps[The many different ways to key Elixir Maps]


There are three different syntax to define a similar maps that can be misleading.

WARNING: You must look carefully if `:` or `=>` are used

[source, elixir]
----
map1 = %{ key: "value" }
map2 = %{ "key": "value" }
map3 = %{ "key" => "value" }

iex(9)> map1
%{key: "value"}

iex(10)> map2
%{key: "value"}

iex(11)> map3
%{"key" => "value"}
----

both `"key":` and `key:` use an atom as the key, instead in the 3rd case the key is a string

This means that map1 and map2 are equivalent and can be matched agaist the same map but the match with map3 will fail because it uses a string as key:

[source, elixir]
----
iex(15)> %{key: value} = map1
%{key: "value"}
iex(16)> %{key: value} = map2
%{key: "value"}
iex(17)> %{key: value} = map3
** (MatchError) no match of right hand side value: %{"key" => "value"}
----

And obtain a similar result with this:

[source, elixir]
----
iex(17)> %{"key": value} = map1
%{key: "value"}
iex(18)> %{"key": value} = map2
%{key: "value"}
iex(19)> %{"key": value} = map3
** (MatchError) no match of right hand side value: %{"key" => "value"}
----

The reverse is true, a String key does't match a symbol key:

[source, elixir]
----
iex(19)> %{"key" => value} = map1
** (MatchError) no match of right hand side value: %{key: "value"}

iex(19)> %{"key" => value} = map2
** (MatchError) no match of right hand side value: %{key: "value"}

iex(19)> %{"key" => value} = map3
%{"key" => "value"}
----

==== Map keys: Anything Else

As keys you can use: Integers, Tuples, Lists, even maps!

[source, elixir]
----
map = %{ 3 => "JB" }
map = %{ {"hi"} => "foo" }
map = %{ [1,"hi"] => "JB" }
----

=== Structs

http://elixir-lang.org/getting-started/structs.html[http://elixir-lang.org/getting-started/structs.html]

Define a Struct with `defstruct`, with defaults:

[source, elixir]
----
defmodule User do
  defstruct name: "John", age: 27  # Keyword list defines what fields the struct will have along with their default values.
end
----

without defaults, `nil` will be assumed ad default:

[source, elixir]
----
defmodule Product do
  defstruct [:name]
end

%Product{}  # %Product{name: nil}
----

To create a User:

* `%User{}` produces `%User{age: 27, name: &quot;John&quot;}` which takes the default values
* `%User{name: &quot;Meg&quot;}` produces `%User{age: 27, name: &quot;Meg&quot;}`, age field is still the default value

To access a User:

[source, elixir]
----
john = %User{}
john.name

----

To create a new User from existing one ():

[source, elixir]
----
john = %User{}                    # %User{age: 27, name: "John"}
laura = %{john|name: "laura"}     # %User{age: 27, name: "laura"}  NOTE: john don't change value
----

Structs VS maps:

* structs are bare maps with a fixed set of fields.
* bare means that none of the protocols implemented for maps are available for structs.For example, you can neither enumerate nor access a struct:
[source, elixir]
----
iex> john = %User{}
%User{age: 27, name: "John"}
iex> john[:name]
** (UndefinedFunctionError) function User.fetch/2 is undefined (User does not implement the Access behaviour)
             User.fetch(%User{age: 27, name: "John"}, :name)
iex> Enum.each john, fn({field, value}) -> IO.puts(value) end
** (Protocol.UndefinedError) protocol Enumerable not implemented for %User{age: 27, name: "John"}
----

But you can use all the function of the https://hexdocs.pm/elixir/Map.html[Map Module]

[source, elixir]
----
iex> kurt = Map.put(%User{}, :name, "Kurt")
%User{age: 27, name: "Kurt"}
iex> Map.merge(kurt, %User{name: "Takashi"})
%User{age: 27, name: "Takashi"}
iex> Map.keys(john)
[:__struct__, :age, :name]
----

* As maps, structs store a “special” field named `__struct__` that holds the name of the struct
* Structs provide compile-time guarantees that only the fields (and all of them) defined through defstruct will be allowed to exist in a struct

==== Required Keys

You can also enforce that certain keys have to be specified when creating the struct:

[source, elixir]
----
defmodule Car do
  @enforce_keys [:make]
  defstruct [:model, :make]
end

iex> %Car{}
** (ArgumentError) the following keys must also be given when building struct Car: [:make]
    expanding struct: Car.__struct__/1
----

==== Derive

Ref: http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/[http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/]

In many situation we want to implement some protocol like `Enumerable` for a struct.

`@derive` allows us to dynamically derive implementations for structs based on the implementation for maps.

[source, elixir]
----
defmodule User do
  @derive [Enumerable]
  defstruct name: "", age: 0
end

Enum.each %User{name: "jose"}, fn {k, v} ->
  IO.puts "Got #{k}: #{v}"
end
#=> Got __struct__: Elixir.User
#=> Got name: jose
#=> Got age: 0
----

The deriving functionality can be customized by implementing `PROTOCOL.Map.__deriving__/3`. For example, a JSON protocol could define a `JSON.Map.__deriving__/3` function that derives specific implementations for every struct. Such implementations could access the struct fields and generate a JSON template at compilation time, avoiding work at runtime.

==== Access Behaviour

https://hexdocs.pm/elixir/Access.html#t:t/0[https://hexdocs.pm/elixir/Access.html#t:t/0]
https://hexdocs.pm/elixir/Kernel.html#update_in/3[https://hexdocs.pm/elixir/Kernel.html#update_in/3]
http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/[http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/]

accessors to make it simpler for developers to traverse nested data structures, traversing and updating data in different ways.

For instance, given a user with a list of languages, here is how to deeply traverse the map and convert all language names to uppercase:

[source, elixir]
----
iex> user = %{name: "john",
...>          languages: [%{name: "elixir", type: :functional},
...>                      %{name: "c", type: :procedural}]}
iex> update_in user, [:languages, Access.all(), :name], &String.upcase/1
%{name: "john",
  languages: [%{name: "ELIXIR", type: :functional},
              %{name: "C", type: :procedural}]}
----

You can see the new accessors in the Access module.

=== Records

WARNING: Are Records will be DEPRECATED http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/[http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/] "Structs are meant to replace Elixir records. "

Records in Elixir are simply tuples supported by modules which store record metadata


= Sigils

http://elixir-lang.org/getting-started/sigils.html[http://elixir-lang.org/getting-started/sigils.html]

Sigils are one of the mechanisms provided by the language for working with textual representations:

* start with the tilde `~` character which is
* followed by a letter (which identifies the sigil)
* and then a delimiter
* optionally, modifiers can be added after the final delimiter

= Operators

== Comparison operators

`a === b`    # strict equality   (so 1 === 1.0 is false)
`a !== b`    # strict inequality (so 1 !== 1.0 is true)
`a ==  b`    # value equality    (so 1 ==  1.0 is true)
`a !=  b`    # value inequality  (so 1 !=  1.0 is false)
`a  &gt;  b`    # normal comparison
`a &gt;=  b`    #   :
`a  &lt;  b`    #   :
`a &lt;=  b`    #   :

The ordering comparisons in Elixir are less strict than in many languages, as you can compare values of different types. If the types are the same or are compatible (for example `3 &gt; 2` or `3.0 &lt; 5`), the comparison uses natural ordering. Otherwise comparison is based on type according to this rule:

`number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; binary`

==  Boolean operators

(These operators expect true or false as their first argument.)

`a or  b`    # true if a is true, otherwise b
`a and b`    # false if a is false, otherwise b
`not a`      # false if a is true, true otherwise

==  Relaxed Boolean operators

These operators take arguments of any type. Any value apart from nil or false is interpreted as true.

`a || b`  a if a is truthy, otherwise b
`a &amp;&amp; b`  b if a is truthy, otherwise a
`!a`      false if a is truthy, otherwise true

== Arithmetic operators

`+     -    *    /  div rem`

Integer division yields a floating-point result. Use `div(a,b)` to get an integer result.

* `rem` is the remainder operator. It is called as a function `(rem(11, 3) =&gt; 2)`. It differs from normal modulo operations in that the result will have the same sign as the function’s first argument.

== Join operators

* `binary1 &lt;&gt; binary2` concatenates two binaries (later we'll see that binaries include strings)
* `list1   ++ list2` concatenates two lists
* `list1   -- list2`   returns elements in list1 not in list2

== The in operator

`a in enum` tests if a is included in enum (for example, a list or a range)

== The pipe operator

Refs:

* http://culttt.com/2016/04/25/using-pipe-operator-elixir/[http://culttt.com/2016/04/25/using-pipe-operator-elixir/]
* https://elixirschool.com/lessons/basics/pipe-operator/[https://elixirschool.com/lessons/basics/pipe-operator/]

The Pipe operator makes easy to combine functions.

In functional languages, you will often want to combine functions by passing the result of one function as the argument to the next.

The pipe operator `|&gt;` passes the result of an expression as the first parameter of another expression.

Example:

* `foo(bar(baz(new_function(other_function()))))` is quite messy
* `other_function() |&gt; new_function() |&gt; baz() |&gt; bar() |&gt; foo()` has the same meaning but much more readable

If you have more than one parameters, for example the `String.ends_with?(string, suffixes)` function, this syntax are equivalent:

[source, elixir]
----
"elixir" |> String.ends_with?("ixir")

String.ends_with?("Elixir","ixir")
----

= Function, Modules and Pattern matching

Ref:

* https://github.com/doomspork/elixir-school/blob/master/lessons/basics/functions.md[https://github.com/doomspork/elixir-school/blob/master/lessons/basics/functions.md]
* http://learningelixir.joekain.com/use-import-require-in-elixir/[http://learningelixir.joekain.com/use-import-require-in-elixir/]

== Modules

Ref:

* Intro: http://elixir-lang.org/getting-started/modules.html[http://elixir-lang.org/getting-started/modules.html]
* Doc: http://elixir-lang.org/docs/stable/elixir/Module.html[http://elixir-lang.org/docs/stable/elixir/Module.html]
* http://culttt.com/2016/04/18/working-functions-modules-elixir/[http://culttt.com/2016/04/18/working-functions-modules-elixir/]

A module is a way of organizing a collection of functions into a namespace. A module basically acts as a namespace.

[source, elixir]
----
defmodule Calculator do
  def sum(a, b) do
    a+b
  end
end
----

`defmodule` create a module

To define functions within a module:
* `def` definine a function
* `defp` definine a private function

iex calculator.ex

=== Nested modules

It is possible to nest modules in Elixir, allowing you to further namespace your functionality:

[source, elixir]
----
defmodule Calculator.Addition do
  def sum(a, b) do
    a+b
  end
end
----

or

[source, elixir]
----
defmodule Calculator do
  defmodule Addition do
    def sum(a, b) do
      a+b
    end
  end
end
----

[source, elixir]
----
defmodule Example.Greetings do
  def morning(name) do
    "Good morning #{name}."
  end

  def evening(name) do
    "Good night #{name}."
  end
end

iex> Example.Greetings.morning "Sean"
"Good morning Sean."
----

=== Private Module Functions

* Function defined with `defp` can be invoked only from a function of the module
* When we don't want other modules accessing a specific function we can make the function private.
* Private functions can only be called from within their own Module
* Error if you call a private func: `UndefinedFunctionError`
[source, elixir]
----
defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

IO.puts Math.sum(1, 2)    #=> 3
IO.puts Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)
----

[source, elixir]
----
defmodule Greeting do
  def hello_public
    hello_private
  end

  defp hello_private
    IO.puts "Hello from a private function"
  end
end

iex(1)> Greeting.hello_public
Hello from a private function
:ok

iex(2)> Greeting.hello_private
** (UndefinedFunctionError) function Greeting.hello_private/0 is undefined or private
    Greeting.hello_private()

----

=== Import and Alias Modules

Ref:

* http://elixir-lang.org/getting-started/alias-require-and-import.html#import[http://elixir-lang.org/getting-started/alias-require-and-import.html#import]
* https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2[https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2]

Use `import` to avoid prefixing the module

[source, elixir]
----
IO.puts "Hello"
puts  #  ** (CompileError) iex:1: undefined function puts/0
import IO
puts "hello"
----

Import only selected functions:

* https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2-selector[https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2-selector]
* `import List, only: [duplicate: 2]` : import only duplicate/2 (with arity 2) function from the List module
* `import List, only: :functions`
* `import List, only: :macros`
* `import List, except: [flatten: 1]` 

Alias a module to add an alternative module name:

[source, elixir]
----
IO.puts "Hello"
alias IO, as: Say
Say.puts "Hello"

----

[source, elixir]
----
defmodule UseImportRequire do
  alias UseImportRequire.AliasMe
  alias UseImportRequire.AliasMe, as: AnotherName

  def alias_test do
    AliasMe.my_function
  end

  def alias_as_test do
     AnotherName.my_function
  end
end
----

* I would recommend using import sparingly. It removes a lot of information which can be a burden for any reader of your code.
* However, there are a few cases where import is helpful. If you are writing a module that is very focused in that it makes heavy use of a specific module then import may make sense.
* One common example is that in a module that makes extensive use of Ecto queries it is common to import Ecto.Query.

The import macro also allows importing of specific functions or macros. This limits “namespace pollution” and can reduce the chance of ambiguity or confusion. Again, this is common with Ecto.Query - the documentation recommends:

[source, elixir]
----
import Ecto.Query, only: [from: 2]
----

in order to import only the Ecto.Query.from/2 macro.

==== Restrict alias and import Scope

As I’ve mentioned there are tradeoffs for using alias and import between convenience and clarity. There is another way to help mitigate this tradeoff. The alias and import macros don’t need to be called at the outer module scope as we have been using them. They can, for example, be called from within another function. Here’s an example using import:

[source, ]
----
defmodule UseImportRequire.WithScope do
  def scope_test do
    import UseImportRequire.ReferenceMe
    function
  end
end
----

=== "use" a module

* http://www.zohaib.me/use-in-elixir-explained/[http://www.zohaib.me/use-in-elixir-explained/]
* https://hexdocs.pm/elixir/Kernel.html#use/2[Elixir Doc]

With `use` developers can inject code into your module. When calling:

[source, elixir]
----
use MyModule, some: :options
----

the `\__using__/1` macro from the MyModule module is invoked with the second argument passed to use as its argument and the module is required. Since *using*/1 is a macro, all the usual macro rules apply, and its return value should be quoted code that is then inserted where use/2 is called.

Behind the scenes, `use` allow the module to inject some code into the current context. Generally speaking, the following module:

[source, elixir]
----
defmodule Example do
  use Feature, option: :value
end
----

is compiled into

[source, elixir]
----
defmodule Example do
  require Feature
  Feature.__using__(option: :value)
end
----

Here’s an example:

[source, elixir]
----
# lib/use_import_require/use_me.ex
defmodule UseImportRequire.UseMe do
  defmacro __using__(_) do
    quote do
      def use_test do
        IO.puts "Use test!"
      end
    end
  end
end
----

and we add this line to UseImportRequire:

[source, elixir]
----
defmodule TestLibrary do
  use UseImportRequire.UseMe
end

iex(1)> TestLibrary.use_test
Use test!
:ok
----

Using `UseImportRequire.UseMe` defines a `use_test/0` function through invocation of the `__using__/1` macro.

Here we have defined a module in which under *using* macro we inject a function.

It is common for the `__using__` macro to in turn call alias, require, or import. This in turn will create aliases or imports in the using module. This allows the module being used to define a policy for how its functions and macros should be referenced. This can be quite flexible in that `__using__/1` may set up references to other modules, especially submodules.

The Phoenix framework makes use of use and `__using__/1` to cut down on the need for repetitive alias and import calls in user defined modules.

Here’s an nice and short example from the Ecto.Migration module:

[source, elixir]
----
defmacro __using__(_) do
  quote location: :keep do
    import Ecto.Migration
    @disable_ddl_transaction false
    @before_compile Ecto.Migration
  end
end
----

The `Ecto.Migration.__using__/1` macro includes an import call so that if use `Ecto.Migration` you also `import Ecto.migration`. It also sets up a module property which I assume control Ecto’s behavior.

To recap: the use macro just invokes the `__using__/1` macro of the specified module. To really understand what that does you need to read the `__using__/1` macro.

=== use VS import VS require

Ref: http://stackoverflow.com/questions/28491306/elixir-use-vs-import[http://stackoverflow.com/questions/28491306/elixir-use-vs-import]

*

`import Module` brings all the Functions and Macros of Module un-namespaced into your module.

*

`require Module` allows you to use macros of Module but does not import them. (Functions of Module are always available namespaced.)

*

`use Module` first requires module and then calls the *using* macro on Module.

Examples:

* Phoenix framework make heavy use of `use`, Crish also wrote a book about it https://pragprog.com/book/cmelixir/metaprogramming-elixir[https://pragprog.com/book/cmelixir/metaprogramming-elixir]
* Exprotobuf make heavy use of `use` https://github.com/bitwalker/exprotobuf[https://github.com/bitwalker/exprotobuf]

==== Ecto Example

Here’s a really nice example of using import:

[source, elixir]
----
defmodule Orthrus.Repo.Migrations.CreateUser do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :name, :string
      add :username, :string
      add :password_hash, :string
      add :email, :string

      timestamps
    end

  end
end
----

The use `Ecto.Migration` call invokes `Ecto.Migration.__using__/1`. And we saw above that this macro in turn calls `import Ecto.Migration`. The import allows us to write very clean code in the migration. We can call create, add, timestamps without needing to clutter up the code with an Ecto.Migration prefix.

For migrations, this is a good tradeoff a migration is narrowly focused task. When you read these references to create table, and add you are in the mindset of thinking about database migrations so this code makes sense.

If you have other tasks that are not as focused you may want to ask yourself if import is the right choice.

=== Require a module

The require macro instructs the compiler to load the specified module before compiling the containing module.

This is only necessary if you want to reference macros from the specified module

=== Module attributes

http://elixir-lang.github.io/getting-started/module-attributes.html
https://www.erlang-solutions.com/blog/elixir-module-attributes-alchemy-101-part-1.html


Module attributes in Elixir serve three purposes:

* They serve to annotate the module, often with information to be used by the user or the VM.
* They work as constants.
* They work as a temporary module storage to be used during compilation.

http://elixir-lang.github.io/getting-started/module-attributes.html#as-annotations

NOTE: Module attributes are evaluated at compile time; All occurrences of the module attribute are replaced with whatever it evaluates to at compile time. https://www.erlang-solutions.com/blog/elixir-module-attributes-alchemy-101-part-1.html [Example]

==== As Annotations

http://elixir-lang.github.io/getting-started/module-attributes.html#as-annotations

Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:

* `@moduledoc` - provides documentation for the current module.
* `@doc` - provides documentation for the function or macro that follows the attribute.
* `@behaviour` - (notice the British spelling) used for specifying an OTP or user-defined behaviour.
* `@before_compile` - provides a hook that will be invoked before the module is compiled. This makes it possible to inject functions inside the module exactly before compilation.

==== As Temporary Storage

http://elixir-lang.github.io/getting-started/module-attributes.html#as-temporary-storage


== Pattern Matching

* http://elixir-lang.org/getting-started/pattern-matching.html[http://elixir-lang.org/getting-started/pattern-matching.html]
* https://elixirschool.com/lessons/basics/pattern-matching/[https://elixirschool.com/lessons/basics/pattern-matching/]
* https://medium.com/@turnandface/pattern-matching-in-elixir-743e71ceac92#.fyyf62wg7[https://medium.com/@turnandface/pattern-matching-in-elixir-743e71ceac92#.fyyf62wg7]
* http://stackoverflow.com/questions/23693173/elixir-pattern-matching-works-differently-for-tuples-and-maps[http://stackoverflow.com/questions/23693173/elixir-pattern-matching-works-differently-for-tuples-and-maps]

`=` operator is actually a match operator.

=== Pattern Matching Tuples

[source, elixir]
----
> {a, b, c} = {:hello, “world”, 42}
{:hello, “world”, 42}
> a
:hello
> b
“world”
> c
42
----

Here the right-hand side of the match operator, =, is a tuple. It has three elements, an atom, a string and an integer. Ok so far.
Now, in order to make the left-hand side equal to the right we’d need to have a three element tuple on the left with with either identical values or ‘placeholders’, variables that can be assigned. Elixir does this by assigning the variables a, b &amp; c into them. We have a match!

In contrast to this, if the tuples have a different number of element there is an error:

[source, elixir]
----
{a, b} = {:hello, “world”, 42}
** (MatchError) no match of right hand side value: {:hello, “world”, 42}
----

In this case, you can pass an underscore on the left-hand side and Elixir will immediately discard the value it matches, while still allowing the match to take place.

[source, elixir]
----
> {a, b, _} = {:hello, “world”, 42}
{:hello, “world”, 42}
----

[source, ]
----
iex(6)> {_,a} = {1,2}
{1, 2}
iex(7)> a
2
----

`_` is the "catch-all" pattern but you need to provide it for all elements of the tuple:

[source, elixir]
----
iex(8)> {_,b} = {1,2,3}
** (MatchError) no match of right hand side value: {1, 2, 3}

iex(8)> {_, b, _} = {1,2,3}
{1, 2, 3}
iex(9)> b
2
----

Taking this one step further, let’s change up the example slightly.

[source, elixir]
----
> {:hello, b, c} = {:hello, “world”, 42}
{:hello, “world”, 42}
> b
“world”
> c
42
----

Here, we’ve hard-coded the first element of the left-hand tuple to :hello. The pattern matching remains the same, can it make the left equal to the right? Here it can, and two variables are created, b and c. This was the start of my understanding of why pattern matching exists.

===  Pattern Matching Lists

[source, elixir]
----
[a, b, _] = [1, 2, 3]
----

or using the `|`:

[source, ]
----
[h|t] = [1, 2, 3]

iex(11)> h
1

iex(12)> t
[2, 3]

----

=== Pattern Matching Maps

When matching maps though, you can match on one or more keys in the map, which gives you thesyntax:

[source, elixir]
----
%{a: b} = %{a: :foo, b: :bar}

----

The semantics are a bit different between data structures, but are fairly common sense.

The tuple rule exists because two tuples cannot be the same unless they have the same number of elements, a list has the same limitation

Because of the semantics of lists, accessing the head element of the list is the most common operation when working with them, hence the [h|t] syntax.

Maps however can match based on specific keys, so the number of elements are irrelevant, as long as both sides of the match contain the same key, and optional pattern for the value, then it's a successful match.

NOTE: maps are the only data structure that allow partial pattern matching, everything else requires the pattern to match the entire structure.

=== Pattern Matching with Structs

Structs can also be used in pattern matching:

* for matching on the value of specific keys
[source, ]
----
iex> %User{name: name} = john
%User{age: 27, name: "John"}
iex> name     #We extract the value of the field name
"John"
----

* for ensuring that the matching value is a struct of the same type as the matched value.
[source, elixir]
----
iex> %User{} = %{}
** (MatchError) no match of right hand side value: %{}
----

=== Pattern Matching with functions

Declare three method definitions with the same name and arity:

[source, elixir]
----
defmodule Chatter do
  def converse({:hello, name, employer}) do
    IO.puts “Hi #{name}. Nice to meet you. I hear you work for #{employer}.”
  end

  def converse({:small_talk, name, fav_hobby}) do
    IO.puts “Hey #{name}, have you been doing much #{fav_hobby} lately?”
  end

  def converse({:goodbye, name}) do
    IO.puts “#{name}, great to talk to you today, goodbye.”
  end
end
----

I can call the converse/1 function thus, the tuple will be passed to the converse/1 function in our Chatter module:

[source, elixir]
----
> Chatter.converse({:hello, “Stephanie”, “World Bank”})
# Hi Stephanie. Nice to meet you. I hear you work for World Bank.
> Chatter.converse({:hello, “Trevor”, “Local Bank”})
# Hi Trevor. Nice to meet you. I hear you work for Local Bank.
> Chatter.converse({:small_talk, “Stephanie”, “fishing”})
# Hey Stephanie, have you been doing much fishing lately?
> Chatter.converse({:goodbye, “Trevor”})
# Trevor, it was great to talk to you today, goodbye.
----

you can see we have allowed for three different types of conversation without any conditionals in our code. Each of the method signatures clearly show their intent through the first element of the tuple. Our code is simplified.

==== Assign variables in the function definition: Phoenix controller example

When I first used Phoenix I saw something I found confusing in some method signatures. Here’s an example from the show action of a controller.

Here’s an example from the show action of a controller:

[source, elixir]
----
def show(conn, %{“user_id” => user_id} = params) do
  # … show stuff here using variables user_id and params
end
----

Hmmm. This `show/2` function takes two parameters, but, in the signature there appears to be some pattern matching going on, this really confused me.

The explanation is quite simple. Elixir is pattern matching params first (the passed in map is the right-hand side, params becomes the left), then pattern matches user_id, as the left-hand side, against params which is now the right-hand side, like so.

[source, elixir]
----
%{“user_id” => user_id} = params = <map passed in>
# breaks down to
params = <map passed in>
# then to
%{“user_id” => user_id} = params
----

As a result of this you have access to the full params map, and a separate user_id in the function body. This is another example of decomposition.

===== Assign variables in the function definition:

https://medium.com/rebirth-delivery/how-to-use-elixir-pattern-matched-functions-arguments-a793733acc6d#.c0l26oy4d[https://medium.com/rebirth-delivery/how-to-use-elixir-pattern-matched-functions-arguments-a793733acc6d#.c0l26oy4d]

==== Pattern Matching and default parameters

http://stackoverflow.com/questions/38820327/pattern-matching-and-default-parameters[http://stackoverflow.com/questions/38820327/pattern-matching-and-default-parameters]

==== The case operator

[source, elixir]
----
# my_case.exs
defmodule MyCase do

  def do_something(tuple) do
    case tuple do
      {:ok, value} -> "The status was :ok!"
      {:nope, value}  - > "Nope nope nope nope..."
      _ -> "You passed in something else."
    end
  end

end
----

Then load up the file in iex by running `$ iex my_case.exs.`

[source, elixir]
----
iex> MyCase.do_something({:ok, true})
"The status was :ok!"
iex> MyCase.do_something({:nope, true})
"Nope nope nope nope..."
iex> MyCase.do_something({:wat, true})
"You passed in something else."
----

=== The pin operator ^


## Guards and multiple clauses

* [Elixir Guard Doc on HEX](https://hexdocs.pm/elixir/guards.html#content)
* Use pattern matching
* support both do: and do/end block syntax


[source, elixir]
----
defmodule Math do
 def zero?(0) do
 true
 end

def zero?(x) when is_integer(x) do
 false
 end
end

IO.puts Math.zero?(0) #=&gt; true
IO.puts Math.zero?(1) #=&gt; false
IO.puts Math.zero?([1, 2, 3]) #=&gt; ** (FunctionClauseError)
IO.puts Math.zero?(0.0) #=&gt; ** (FunctionClauseError) 
----

[source, elixir]
----
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end
----

== One line function definition

To make small function much more readable you can use this compact syntax:

[source, elixir]
----
defmodule Calculator do
  def sum(a, b), do: a + b
end
----

== Function Capturing - &amp; operator

[source, elixir]
----
iex> Math.zero?(0)
true
iex> fun = &Math.zero?/1
&Math.zero?/1
iex> is_function(fun)
true
iex> fun.(0)
true
----

If you want to capture a function from a module, you can do &amp;Module.function():

[source, elixir]
----
iex> fun = &List.flatten(&1, &2)
&List.flatten/2
iex> fun.([1, [[2], 3]], [4, 5])
[1, 2, 3, 4, 5]
----

== &amp; shortcut for creating functions

Shorthand to create anonymous functions

[source, elixir]
----
iex> sum = &(&1 + &2)
iex> sum.(2, 3)
5
----

Parameters are available to us as &amp;1, &amp;2, &amp;3, and so on

== Closures

ref: http://joearms.github.io/2013/05/31/a-week-with-elixir.html[http://joearms.github.io/2013/05/31/a-week-with-elixir.html]

Closures in Elixir (fn's) are really just closures in Erlang (fun's).

`fn` capture the present value of any variables that are in their scope (ie we can create immutable closures). This is something that JavaScript gets very wrong.

Here's an example in JavaScript and Elixir so you can see the difference:

[source, elixir]
----
js> a = 5;
5
js> f = function(x) { return x+a };
function (x){return x+a}
js> f(10)
15
js> a = 100
100
js> f(10)
110
----

We broke the function f:

* We define a function f,
* start using it.
* Redefine a and this has the side effect of breaking f.

One of the good things about functional programming is that it makes it easy to reason about programs. If f(10) evaluates to 15 then it should evaluate to 15 forever, you should not be able to remotely break it.

What about Elixir? This gets closures right:

[source, elixir]
----
iex> a = 5
5
iex> f = fn(x) -> x + a end
#Function
iex> f.(10)
15
iex> a = 100
100
iex> f.(10)
15
----

* Proper closures should only contain pointers into immutable data (which is the case in Erlang) - no pointers into mutable data.
* If a closure contains a pointer into mutable data and you change the data later you break the closure. This means you can't parallelize your program and even sequential code can contain weird errors.
* In a conventional language creating proper closures would be very expensive since it would require deep copying of all the variables that are captured in the environment, but this is not the case in Erlang or Elixir, since data once written is immutable. All you can do later is refer to it.
* Internally this is through a pointer (which the programmer never sees) and the garbage collector removes all data that can never be referenced since nothing points to it.

== Compilation

* `elixirc math.ex` generate `Elixir.Math.beam`
*  

== def VS fn

* http://stackoverflow.com/questions/18011784/why-are-there-two-kinds-of-functions-in-elixir[http://stackoverflow.com/questions/18011784/why-are-there-two-kinds-of-functions-in-elixir]

== With

* Elxir DOC: https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1[https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1]
* http://learningelixir.joekain.com/learning-elixir-with/[http://learningelixir.joekain.com/learning-elixir-with/]
* http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html#with[http://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html#with]

The pipe operator is great when all functions are acting on a consistent piece of data. It falls apart when we introduce variability.

That's where `with` comes in. with is a lot like a |&gt; except that it allows you to match each intermediary result. It allows developers to match on multiple expressions concisely

Previously, one would write

[source, elixir]
----
case File.read("my_file.ex") do
  {:ok, contents} ->
    case Code.eval_string(contents) do
      {res, _binding} ->
        {:ok, res}
      error ->
        error
  error -> error
    error
end
----

such can now be rewritten as

[source, elixir]
----
with {:ok, contents} <- File.read("my_file.ex"),
     {res, binding} <- Code.eval_string(contents),
     do: {:ok, res}
----

with will match each left side of `&lt;-` against the right side, executing expressions until one of those match fails or until the do: expression is performed.

In case a match fails, the non-matching result is returned. An `else` option can be given to modify what is being returned from with in the case of a failed match:

* use left arrow
* can have multiple pattern matching clauses
* use-case: you want to return an uniform return value for all the errors that can happen in your chain

If there is no matching else condition, then a `WithClauseError` exception is raised.

[source, elixir]
----
with ... <- ... ,
    ... <- ... ,
    ... <- ... ,
    ... <- ... do
  {:ok, double_width * height}
else
  :error -> {:error, :wrong_data}
  :error2 -> {:error, :nil_data}
end
----

NOTE that:

* non andare a capo con il `do` quando si usa `else`
* “bare expressions” may also be inserted between the clauses
* Guards can be used in patterns
* variables bound inside with/1 won’t leak;

Example:

[source, elixir]
----
width = nil
opts = %{width: 10, height: 15}
with {:ok, width} <- Map.fetch(opts, :width),
    double_width = width * 2,
    {:ok, height} <- Map.fetch(opts, :height),
    do: {:ok, double_width * height}

{:ok, 300}

width = nil
opts = %{width: 10}
with {:ok, width} <- Map.fetch(opts, :width),
    double_width = width * 2,
    {:ok, height} <- Map.fetch(opts, :height),
    do: {:ok, double_width * height}

:error

width = nil
opts = %{width: 10}
a = with {:ok, width} <- Map.fetch(opts, :width),
    double_width = width * 2,
    {:ok, height} <- Map.fetch(opts, :height) do
  {:ok, double_width * height}
else
  :error -> {:error, :wrong_data}
end

{:error, :wrong_data}
----

Refactor example: http://openmymind.net/Elixirs-With-Statement/[http://openmymind.net/Elixirs-With-Statement/]

=== Happy With

If you want to be more specific in the way you handle errors and you cannot obtain it with patter matching use `happy_with` and `tags`:

* https://github.com/vic/happy_with[https://github.com/vic/happy_with]
* https://github.com/vic/happy/blob/master/README.md#tags[https://github.com/vic/happy/blob/master/README.md#tags]

= Elixir Macros

* TODO http://elixir-lang.org/getting-started/meta/macros.html[http://elixir-lang.org/getting-started/meta/macros.html]
* http://slides.com/chrismccord/elixir-macros#/14[http://slides.com/chrismccord/elixir-macros#/14]

Warning about macros: Remember that explicit is better than implicit. Clear code is better than concise code.

MACRO RULE #1 : DON'T WRITE MACROS

MACRO RULE #2 : USE MACROS GRATUITOUSLY

What is a macro:

* Code that writes code
* Elixir itself is primarily built with macros (if, unless, cond, def, defmodule)
* Full access to Elixir at compile time

`quote`Returns the representation of any expression (AST)

* AST is represented as a series of three element tuples
* The first element is always an atom or another tuple
* The second element represents metadata
* The third element is the arguments for the function call
[source, elixir]
----
iex> quote do: div(10, 2)
{:div, [], [10, 2]}
----

[source, elixir]
----
iex> add = fn a, b -> a + b end

iex> quote do: add.(1, 2)
{
  {:., [], [{:add, [], Elixir}]},
  [],
  [1, 2]
}
----

ASSERT MACRO

== Macro use-cases

* Eliminating boilerplate
* Advanced compile time code generation
* Domain Specific Languages (DSLs)


= Specifications and types

Ref:

* http://elixirschool.com/lessons/advanced/typespec/[Elixir School]
* https://hexdocs.pm/elixir/typespecs.html[Elixir Doc: Typespec]
* https://hexdocs.pm/elixir/typespecs.html#types-and-their-syntax[List of Elixir types]
* The_Little_Elixir_&amp;_OTP_Guidebook.pdf CH 10.5

Elixir comes with a notation for declaring types and specifications.

Use case:

* Defines callback for Behaviours
* Hint for static analyzer tools like Dialyzer
* Documentation: with dynamic languages, valid inputs and the type of the return value are sometimes not obvious.

Type specifications (sometimes referred to as typespecs) are defined in different contexts using the following attributes:

* `@spec function_name(type1, type2) :: return_type` : specification of function that will be checked by compiler.
* `@type type_name :: type` :
* `@typep type_name :: type`
* `@opaque type_name :: type`
* `@callback function_name(type1, type2) :: return_type`
* `@macrocallback macro_name(type1, type2) :: Macro.t`

NOTE: Elixir is still dynamic language, that means all information about type will be ignored by compiler, but could be used by other tools.

types can be:

* Built-in types https://hexdocs.pm/elixir/typespecs.html[https://hexdocs.pm/elixir/typespecs.html])
* Parametrized types: `list(integer)`
* Union types: a type made of one or more types, ex: `integer | float`
* Remote types

To match a Struct inside a typespec, use the normal %StructName{} syntax.

== Types


* https://hexdocs.pm/elixir/typespecs.html#basic-types[Basic types]
* https://hexdocs.pm/elixir/typespecs.html#literals[Literals]
* https://hexdocs.pm/elixir/typespecs.html#built-in-types[Built in types]
* https://hexdocs.pm/elixir/typespecs.html#remote-types[Remote Types] : Types defined in a Module
* https://hexdocs.pm/elixir/typespecs.html#user-defined-types[User Defined Types]: `@type`, `@typep`, `@opaque`

NOTE: Types can be parameterized by defining variables as parameters https://elixirschool.com/en/lessons/advanced/typespec/

== Example

=== Keyword List type check

https://elixirforum.com/t/typespecs-best-way-to-spec-keyword-lists/2991/2[https://elixirforum.com/t/typespecs-best-way-to-spec-keyword-lists/2991/2]

`[key1: type1, key2: type2]` actually means the same as `[{:key1, type1} | {:key2, type2}]`:

* Order does not matter
* an empty list is OK
* unknown keys are rejected.

[source, elixir]
----
defmodule TypeSpecDemo do

  @spec hello([bar: String.t, baaz: String.t]) :: {:world, list}
  def hello(opts \\ []) do
    {:world, opts}
  end

  # correct usage
  def default_to_empty_list, do: hello()
  def call_with_empty_list, do: hello([])
  def first_key_only, do: hello(bar: "bar")
  def second_key_only, do: hello([baaz: "baaz"])
  def both_keys_in_order, do: hello([bar: "bar", baaz: "baaz"])
  def both_keys_reversed, do: hello([baaz: "baaz", bar: "bar"])

  # incorrect usage
  def bad_arg, do: hello("world")
  def unknown_key, do: hello(foo: "foo")
  def wrong_value, do: hello(baaz: 15)
end
----

To test it:

* `_guides/elixir_examples/dialyzer_playground/lib/keyword_list_example.ex`
* `mix dialyzer|grep keyword_list_example`

=== Example 1

The `Range` module defines a Range struct and a type `t`

[source, elixir]
----
https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/range.ex#L42

defmodule Range do
  defstruct first: nil, last: nil

  @type t :: %Range{first: integer, last: integer}
  @type t(first, last) :: %Range{first: first, last: last}
----

that can be referred as `Range.t`

[source, elixir]
----
defmodule Cashy.Prova do

  @spec test_remote_type(Range.t) :: Range.t
  def test_remote_type(a) do
    a
  end

  def run do
    test_remote_type(1..2)
  end
end
----

=== Example 2

A `Library.Book` struct that has a single property of `:title`. I’ve then defined a custom type using this struct. I’ve also declared that the :title property should be a string.

[source, elixir]
----
defmodule Library.Book do
  defstruct [:title]

  @typedoc """
  A custom type that holds the properties of a book
  """
  @type t :: %Library.Book{title: String.t}
end
----

We can now update the specs from earlier to use this new custom book type:

[source, elixir]
----
@spec add(Library.Book.t) :: :ok
@spec all :: list(Library.Book.t)
----

= Protocols

Refs:

* http://culttt.com/2016/06/27/what-are-elixir-protocols/[http://culttt.com/2016/06/27/what-are-elixir-protocols/]
* http://elixir-lang.org/getting-started/protocols.html[http://elixir-lang.org/getting-started/protocols.html]
* https://blog.usejournal.com/beyond-functions-in-elixir-refactoring-for-maintainability-5c73daba77f3[Blog Engine example]


Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a protocol is available to any data type as long as it implements the protocol.

Polymorphism:

* Describes functions that can have different implementations for different types.
* In programming this means you can usually act on something in a generic way, without knowing specifically what the thing is.
* As long as the thing you are acting on knows how to handle the action, you’re good to go. This is polymorphism because it doesn’t matter what the thing is, as long as it responds correctly.

TIP: You use protocol to print something as a string, without knowing what the thing is.

[source, elixir]
----
to_string("Hello World")
"Hello World"

to_string(123)
"123"

to_string(99.9)
"99.9"
----

Structs alongside protocols provide data polymorphism in Elixir.

The real power of Protocols comes when you combine its polymorphism with structs. When you pass a struct to a protocol function, it will dispatch to that structs implementation.

TODO: link alla definizione di function head

You can think of Protocols just like you think of pattern matching with multiple function heads. In fact, when you compile your Elixir code in production mode, they get compiled down to exactly that.

The main difference between Protocols and pattern matching on different values is the *inversion of control*.

Elixir provides both *closed ad-hoc polymorphism* via pattern matching on function clauses and *open ad-hoc polymorphism* via protocols (which are close to interfaces). ref: https://elixirforum.com/t/behaviours-defoverridable-and-implementations/3338/9 

Protocols let you add more “function heads” after the fact, so that app and library developers can match on their type separate from the definition of the Protocol itself, they are not required to implement every possible function heads. 

Is impossible for a library developer to know every type the app developer will needs, in this case protocols come to the rescue.

Example:

[source, elixir]
----
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end
----

The Size protocol expects a function called size that receives one argument (the data structure we want to know the size of) to be implemented. We can now implement this protocol for the data structures that would have a compliant implementation:

[source, elixir]
----
defimpl Size, for: BitString do
  def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
----

We didn’t implement the Size protocol for lists as there is no “size” information precomputed for lists, and the length of a list has to be computed (with length/1).

== Elixir Standard Protocols

Elixir comes with several protocols out of the box; Collectable, Enumerable, Inspect, List.Chars, and String.Chars.

Example: https://hexdocs.pm/elixir/Collectable.html#content[https://hexdocs.pm/elixir/Collectable.html#content]

== Example: Temperature Protocol

https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929[https://medium.com/@mustafaturan/polymorphism-in-elixir-cd0c765b6929]

= Behaviours

Behaviours in Elixir (and Erlang) are a way to separate and abstract an API interface:

* `the behaviour module` : which is the generic part that define the interface
* `the callback module` the specific part that implement the behaviour

Behaviours perform two primary roles:

* Defining a set of function that must be implemented.
* Checking whether that set was actually implemented (you will get compiler warning).

For example, the `GenServer` behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a “server” process will likely want to implement from the specific parts such as the actions that this server process has to perform.

Ref:

* https://hexdocs.pm/elixir/behaviours.html#content[Elixir Doc: Behaviours]
* http://elixirschool.com/lessons/advanced/behaviours/[http://elixirschool.com/lessons/advanced/behaviours/]
* https://www.djm.org.uk/posts/writing-extensible-elixir-with-behaviours-adapters-pluggable-backends/[https://www.djm.org.uk/posts/writing-extensible-elixir-with-behaviours-adapters-pluggable-backends/]
*

* https://www.djm.org.uk/posts/writing-extensible-elixir-with-behaviours-adapters-pluggable-backends/[https://www.djm.org.uk/posts/writing-extensible-elixir-with-behaviours-adapters-pluggable-backends/]

== Defining the behaviour module

To better understand behaviours let’s implement one for a worker module. These workers will be expected to implement two functions: `init/1` and `perform/2`.

In order to accomplish this, we’ll use:

* the `@callback` directive with syntax similar to `@spec`, this defines a required function;
* for macros we can use `@macrocallback`.

Let’s specify the `init/1` and `perform/2` functions for our workers:

[source, elixir]
----
defmodule Example.Worker do
  @callback init(state :: term) :: {:ok, new_state :: term} | {:error, reason :: term}
  @callback perform(args :: term, state :: term) ::
              {:ok, result :: term, new_state :: term}
              | {:error, reason :: term, new_state :: term}
end
----

Here we’ve defined init/1 as accepting any value and returning a tuple of either `{:ok, state}` or `{:error, reason}`, this is a pretty standard initialization. Our `perform/2` function will receive some arguments for the worker along with the state we initialized, we’ll expect `perform/2` to return `{:ok, result, state}` or `{:error, reason, state}` much like `GenServers`.

== Implementing the callback module

Adding a behaviour to our module is easy with the `@behaviour` attribute.

[source, exixir]
----
defmodule Example.Compressor do
  @behaviour Example.Worker

  def init(opts), do: {:ok, opts}

  def perform(payload, opts) do
    payload
    |> compress
    |> respond(opts)
  end

  defp compress({name, files}), do: :zip.create(name, files)

  defp respond({:ok, path}, opts), do: {:ok, path, opts}
  defp respond({:error, reason}, opts), do: {:error, reason, opts}
end
----

If we happen to add a behaviour but fail to implement all of the required functions, a compile time warning will be raised `warning: undefined behaviour function`;

== Optional Callback

https://hexdocs.pm/elixir/behaviours.html#optional-callbacks

Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. 

To check if the callbacks are defined you can use `function_exported?/3` or `macro_exported?/3`.

NOTE: https://elixirforum.com/t/behaviours-defoverridable-and-implementations/3338[here] is documented an antipattern that Optional callbacks resolves: before it exists developers create an overridable version of the optional function which throws an exception if invoked.

== @impl: mark which functions are an implementation of a callback

Elixir v1.5 introduces the `@impl <MYBEAHVIOUR>` or `@impl true` attribute, which allows us to mark that certain functions are implementation of callbacks.

Why is it useful? Once more and more behaviour and functions are added to the module, it becomes increasingly harder to know the purposes of each of them. 

For example, when using the Plug project, one needs to implement both `init/1` and `call/2` when writing a Plug:

[source, elixir]
----
defmodule MyApp do
  @behaviour Plug

  @impl Plug
  def init(_opts) do
    opts
  end

  @impl Plug
  def call(conn, _opts) do
    Plug.Conn.send_resp(conn, 200, "hello world")
  end
end
----

NOTE: you can ues `@impl true` without specifing the behaviour but it's much less readable

Overall, using @impl has the following advantages:

* Readability of the code is increased, as it is now clear which functions are part of your API and which ones are callback implementations. To reinforce this idea, @impl true automatically marks the function as @doc false, disabling documentation unless @doc is explicitly set

* If you define @impl before a function that is not a callback, Elixir will error. This is useful in case of typos or in case the behaviour definition changes (such as a new major version of a library you depend on is released)

* If you use @impl in one implementation, Elixir will force you to declare @impl for all other implementations in the same module, keeping your modules consistent

== Crete default implementations: defoverridable and use

Ref:

* https://elixirforum.com/t/behaviours-defoverridable-and-implementations/3338

To create a default implementation of behaviour's function you can combine:

* `use` 
* `defoverridable` https://hexdocs.pm/elixir/Kernel.html#defoverridable/1[doc]

A good example is the GenServer behaviour https://github.com/elixir-lang/elixir/blob/v1.5.3/lib/elixir/lib/gen_server.ex#L1 

[source, elixir]
----
defmodule GenServer do
  @callback init(args :: term) ::
    {:ok, state} |
    {:ok, state, timeout | :hibernate} |
    :ignore |
    {:stop, reason :: any} when state: any
  
  @callback terminate(reason, state :: term) ::
    term when reason: :normal | :shutdown | {:shutdown, term} | term
    
    ....
    
  defmacro __using__(_) do
    quote do
      @behaviour GenServer      # 1
      def init(...) do ... end  # 2
      def terminate(..., ...) do ... end
      .....
      defoverridable GenServer  # 3
    end
  end
end

defmodule MyServer do
  use GenServer
end
----

In this example the MyServer callback module implements the GenServer behaviour and all it's callback in one line because through the `__using__` macro:

* 1 invoke `@behaviour GenServer`
* 2 defines a default implementation for all the GenServer callback
* 3 make all GenServer callback overridable with `defoverridable GenServer`

NOTE: `super` can be used to call the default implementation when you reimplement a overridable function.

== Use @spec with Behaviour

Sadly it's not possible to check if we are using a module that implements a given behaviour:

* https://stackoverflow.com/questions/44731975/how-to-use-typespecs-and-dialyzer-with-behaviours
* https://elixirforum.com/t/behaviour-and-typespec/3408/2

= Behaviour VS Protocols

Protocols VS Behaviors: https://www.djm.org.uk/posts/elixir-behaviours-vs-protocols-what-is-the-difference/[https://www.djm.org.uk/posts/elixir-behaviours-vs-protocols-what-is-the-difference/]

Poly = many. Morph = change or form. Polymorphism is the ability in programming to present the same interface for differing underlying forms. What does that mean for us? Protocols allow the defining of interfaces (a series of functions) which can go on to be implemented by any data type and then used generically; and Behaviours define a common interface to a module, so that modules can be used interchangeably. Don't worry if you're lost, we'll delve deeper later.

If you're ever added a float to an integer in a dynamic language, this is under-the-hood polymorphism at work. Both of them are numbers to us but they are stored differently in memory and are therefore different from the perspective of a computer. Polymorphism allows us to do calculations between the two data types without worrying about their underlying differences. In most languages, this happens behind the scenes by defining a common contract.

Elixir can mostly be thought of in terms of 3 core things: processes, modules & data. In José's words: "they are all interconnected: processes run the code defined in modules that manipulate the data types" ¹.

All 3 have their own way of "doing" polymorphism in Elixir:

= Processes and the actor model

Ref:

* The_Little_Elixir_&amp;_OTP_Guidebook.pdf CH3 is a good intro

== Processes

* are the fundamental units of concurrency in Elixir (supports up to 134 million processes)
* processes created by the Erlang VM are independent of the operating system
* take mere microseconds to create

== Actor concurrency model

Erlang (and therefore Elixir) uses the Actor concurrency model. This means the following:

* Each actor is a process.
* Each process performs a specific task.
* To tell a process to do something, you need to send it a message. The process can reply by sending back another message.
* The kinds of messages the process can act on are specific to the process itself. In other words, messages are pattern-matched.
* Other than that, processes don’t share any information with other processes.

If you've done objet-oriented programming, you could argue that the Actor is a purer form of object-orientation.

A PID is a reference to a process, much as in object-oriented programming the result of initializing an object is a reference to that object. With the pid, you can send the process messages. The kinds of messages the process can receive are defined in the receive block

`receive` Checks if there is a message matching the given clauses in the current process
mailbox.

To create a process use `spawn(fun)`:

* Spawns the given function and returns its PID.
* `child   = spawn(fn -&gt; send current, {self(), 1 + 2} end)`

OR `spawn(module, fun, args)`:

* `spawn(SomeModule, :function, [1, 2, 3])`
* Spawns the given module and function passing the given args and returns its PID.

OR `Process` and `Node` modules for other functions to handle processes, including spawning functions in nodes.

NOTE: it’s good practice to have the match-all case as the last message to be matched. This is because unmatched messages are kept in the mailbox. Therefore, it’s possible to make the VM run out of memory

`send/2`:

* Sends a message to the given dest and returns the message.
* `send self(), :hello`
* message can be any structure: `send(pid, {self, &quot;Singapore&quot;})`

`flush/0`: Flushes all messages sent to the shell and prints them out.

NOTE: there’s no shared memory. The only way a change of state can occur within a process is when a message is sent to it. This is different from threads, because threads share memory. This means multiple threads can modify the same memory—an endless source of concurrency bugs (and headaches).

=== Process Module

* Process.alive?(pid)
* Process.info(pid)
*

TODO molte info da capire

= OTP

Ref:

* The_Little_Elixir_&amp;_OTP_Guidebook.pdf CH4

== Gen server

REF:

* The_Little_Elixir_&amp;_OTP_Guidebook.pdf CH4
* Source code: https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/gen_server.ex#L1[https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/gen_server.ex#L1]
* https://medium.com/@StevenLeiva1/understanding-elixir-s-genserver-a8d5756e6848[https://medium.com/@StevenLeiva1/understanding-elixir-s-genserver-a8d5756e6848]

GenServer:

* is nothing more than a module (it simply a container for a set of functions and / or macros).
* is a type of module called a behavior.

A behavior is simply a way to define what functions a module must implement.

TESTING a Genserver: http://elixir-lang.org/getting-started/mix-otp/genserver.html#testing-a-genserver[http://elixir-lang.org/getting-started/mix-otp/genserver.html#testing-a-genserver]

https://hexdocs.pm/elixir/Kernel.html#defoverridable/1[defoverridable] :

* Makes the given functions in the current module overridable.
* `super` can be used to call the default implementation.

== Supervisor

TODO: https://jbodah.github.io/blog/2016/11/18/supervisors-work/[https://jbodah.github.io/blog/2016/11/18/supervisors-work/]

= Applications and use cases

Elixir and big data: https://elixirforum.com/t/big-data-with-elixir/154/2[https://elixirforum.com/t/big-data-with-elixir/154/2]

Leveraging Elixir to access HDFS-like and inter-operate to Python for the map-reduce or machine-learning, and back again to Elixir for the database and Web inter-operability. This can be done by using protobuffer or a common swap space.
Again, one of the weakness of the software you mentioned is of being monolithic and to enforce the use of certain tools (above all Java).

= Escript: Executables and command line tools with Elixir

Escript produces an executable that can be run on any system with Erlang installed.

* http://asquera.de/blog/2015-04-10/writing-a-commandline-app-in-elixir/[http://asquera.de/blog/2015-04-10/writing-a-commandline-app-in-elixir/]
* https://elixirschool.com/lessons/advanced/escripts/[https://elixirschool.com/lessons/advanced/escripts/]

To install into `~/.mix/escripts` (which must be added to your PATH): `mix escript.install`

= Code Snippet

== Iterate over an Enumerable ()

[source, elixir]
----
Enum.each %{foo: :bar}, fn {k, v} ->
  IO.puts "Got #{k}: #{v}"
end
----

== Reading a file

Page 45 The_Little_Elixir_&amp;_OTP_Guidebook.pdf

== Tic-Tac-Toe board

Page 46 The_Little_Elixir_&amp;_OTP_Guidebook.pdf

== Parsing MP3 file

Page 47 The_Little_Elixir_&amp;_OTP_Guidebook.pdf

== Commandline option parsing

https://hexdocs.pm/elixir/OptionParser.html[https://hexdocs.pm/elixir/OptionParser.html]

= Common Libraries

== Authentication

=== Guardian

https://github.com/ueberauth/guardian?utm_source=elixirdigest&utm_medium=web&utm_campaign=featured[https://github.com/ueberauth/guardian?utm_source=elixirdigest&utm_medium=web&utm_campaign=featured]

= Recipes

https://elixir-examples.github.io/[https://elixir-examples.github.io/]
